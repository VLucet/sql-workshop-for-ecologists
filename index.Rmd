---
title: "SQL For Ecologists: An Introduction"
subtitle: "_With comparisons to both tidyverse and base R code_"  
author: 
  - "Valentin Lucet"
date: 'July 2021'
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    nature:
      slideNumberFormat: "%current%"
      highlightStyle: github
      highlightLines: true
      ratio: 4:3
      countIncrementalSlides: true
---
name: prereqs
```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(
  fig.width=9, fig.height=3.5, fig.retina=3,
  out.width = "100%",
  cache = FALSE,
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  fig.show = TRUE,
  hiline = TRUE
)
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_duo(primary_color = "#1F4257", secondary_color = "#F97B64")
```

```{r import-data, include=FALSE, warning=FALSE}
library(tidyverse)
surveys <- read_csv("../data/surveys.csv")
species <- read_csv("../data/species.csv")
plots <- read_csv("../data/plots.csv")
locations <- read_csv("../data/locations.csv")
```

### Prerequisites

This workshop is adapted from the Data Carpentry workshop titled: [Data Management with SQL for Ecologists](https://datacarpentry.org/sql-ecology-lesson/), and aims to introduce ecologists to databases and the SQL (pronounced "sequel") language by comparing the SQL code to R code, both in base R and in the tidyverse syntax.

Therefore, a basic knowledge of data manipulation in R (base or tidy-style) will be beneficial. The only other requirements are to follow the instructions for setup at [this setup link](https://datacarpentry.org/sql-ecology-lesson/setup.html). Namely:

1. [Download](https://figshare.com/articles/Portal_Project_Teaching_Database/1314459) and unzip the data.

2. Install [DB Browser for SQLite](http://sqlitebrowser.org/) and any required dependencies.

---
name: plan
### Workshop plan

1. _Introducing Databases and SQL_
  - What is a database? 
  - What does it mean for a database to be relational?
  - What are the best practices in designing a database?

2. _Accessing Data With Queries_
  - What is a query?
  - How can I export the results of a query?

3. _Aggregating and Grouping Data_
  - How can more complex queries be used to manipulate data?
  - How does it compare to doing it in R?

4. _Combining Data With Joins_
  - Why are joins important?
  - How can joins be tricky?
  

---
class: inverse center middle
# Introducing Databases and SQL

---
## Goals

To answer simple questions about data, we might want to:

* Select subsets of the data (rows and columns)

* Group subsets of data

* Do math and other calculations

* Combine data across spreadsheets

Putting our data into a **relational database** and using **SQL** will help us achieve these goals.

---
## What is SQL?

SQL stands for **Structured Query Language**. SQL allows us to interact with **relational databases** through **queries**. These queries can allow you to perform a number of actions such as: insert, select, update and delete information in a database.

![](figures/SQL.png)

---
## What is a relational database?

A **relational database** stores data in relations made up of *records* with *fields*. 

* The relations are usually represented as *tables*:
  * Record are usually shown as rows
  * Fields are usually shown as columns
  
* In most cases, each record will have a *unique identifier*, called a **key**, which is stored as one of its fields.

* Records may also contain keys that refer to records in other tables, which enables us to combine information from two or more sources.

---
## A relational database example

The data we will be using is a (real) time-series for a small mammal community in southern Arizona. This is part of a project studying the effects of rodents and ants on the plant community. The rodents are sampled on a series of 24 plots, with different experimental manipulations controlling which rodents are allowed to access which plots.

![](figures/DB.png)
---
## Why use relational databases?

* Keeps your data separate from your analysis: this means there’s no risk of accidentally changing data when you analyze it.

* If we get new data we can rerun the query.

* It’s fast, even for large amounts of data.

* It improves quality control of data entry (type constraints and use of forms in MS Access, Filemaker, Oracle Application Express etc.)

* The concepts of relational database querying are core to understanding how to do similar things using programming languages such as R or Python.

---
## Database Design

1. Every row-column combination contains a single atomic value, i.e., not containing parts we might want to work with separately.

2. One field per type of information.

3. No redundant information.

4. Split into separate tables with one table per class of information.

5. Needs an identifier in common between tables – shared column - to reconnect (known as a foreign key).

---
## SQL Data Type Quick Reference

![](figures/types.png)
---
## Hands on

1. DEMO: how to create a new database from scatch in DB Browser

2. Short exercise: Explore the `portal_mammals.sqlite` database 
  
  a. Add a new field to one of the tables.

---
class: inverse center middle
# Accessing Data With Queries

---
## Selecting
#### *Selecting all records*
##### SQL

```SQL
SELECT *
FROM surveys;
```
--

##### BASE

```{r, results = FALSE}
surveys[,]
```

##### TIDYVERSE

```{r, results = FALSE}
surveys %>% select(everything())
```

---
## Selecting
#### *Selecting a column*
##### SQL

```SQL
SELECT year
FROM surveys;
```
--

##### BASE

```{r, results = FALSE}
surveys[,"year"]
```

##### TIDYVERSE

```{r, results = FALSE}
surveys %>% select(year)
```

---
## Selecting
#### *Selecting multiple columns*
##### SQL

```SQL
SELECT year, month, day
FROM surveys;
```
--

##### BASE

```{r, results = FALSE}
surveys[,c("year", "month", "day")]
```

##### TIDYVERSE

```{r, results = FALSE}
surveys %>% select(year, month, day)
```

---
## Limiting results
#### *Limiting to the 10 first records*
##### SQL

```SQL
SELECT *
FROM surveys
LIMIT 10; 
```
--

##### BASE

```{r, results = FALSE}
surveys[1:10,]
```

##### TIDYVERSE

```{r, results = FALSE}
surveys %>% select(everything()) %>% slice(1:10)
```

---
## Unique values
#### *Get all unique value for a column*
##### SQL

```SQL
SELECT DISTINCT species_id
FROM surveys;
```
--

##### BASE

```{r, results = FALSE}
unique(surveys[,"species_id"])
```

##### TIDYVERSE

```{r, results = FALSE}
surveys %>% select(species_id) %>% unique()
```

---
## Unique values
#### *Get all unique value for a combination of columns*
##### SQL

```SQL
SELECT DISTINCT year, species_id
FROM surveys;
```
--

##### BASE

```{r, results = FALSE}
unique(surveys[,c("year", "species_id")])
```

##### TIDYVERSE

```{r, results = FALSE}
surveys %>% select(year, species_id) %>% unique()
```

---
## Calculated values
#### *Calculating values on the fly*
##### SQL

```SQL
SELECT year, month, day, weight * 1000
FROM surveys;
```
--

##### BASE

```{r, results = FALSE}
surveys_tmp <- surveys[,c("year", "month", "day", "weight")]
surveys_tmp$weight_1000 <- surveys_tmp$weight * 1000
```

##### TIDYVERSE

```{r, results = FALSE}
surveys %>% select( year, month, day, weight) %>% 
  mutate(weight_1000 = weight * 1000)
```


---
## Counting
##### SQL

```SQL
SELECT COUNT(*)
FROM surveys;
```

##### BASE

```{r, results = FALSE}
nrow(surveys)
```

##### TIDYVERSE

```{r, results = FALSE}
nrow(surveys)
```
